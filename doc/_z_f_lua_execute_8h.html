<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ZFFramework: ZFLuaExecute.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript">var page_layout=1;</script>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="side-nav" class="ui-resizable side-nav-resizable"><!-- do not remove this div, it is closed by doxygen! -->
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ZFFramework
   </div>
  </td>
 </tr>
   <tr><td colspan="2">        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td></tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('_z_f_lua_execute_8h.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">ZFLuaExecute.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>execute lua script  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="_z_f_lua_def_8h_source.html">ZFLuaDef.h</a>&quot;</code><br />
</div>
<p><a href="_z_f_lua_execute_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a3c13beac94e3fba795f03e308d2cbd22" id="r_a3c13beac94e3fba795f03e308d2cbd22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classzfauto.html">zfauto</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c13beac94e3fba795f03e308d2cbd22">ZFLuaExecute</a> (const <a class="el" href="class_z_f_input.html">ZFInput</a> &amp;input)</td></tr>
<tr class="memdesc:a3c13beac94e3fba795f03e308d2cbd22"><td class="mdescLeft">&#160;</td><td class="mdescRight">main entry for lua module, execute lua code  <br /></td></tr>
<tr class="separator:a3c13beac94e3fba795f03e308d2cbd22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b62342afcf8432691f6fd69c51a0b8b" id="r_a8b62342afcf8432691f6fd69c51a0b8b"><td class="memItemLeft" align="right" valign="top"><a id="a8b62342afcf8432691f6fd69c51a0b8b" name="a8b62342afcf8432691f6fd69c51a0b8b"></a>
<a class="el" href="classzfauto.html">zfauto</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ZFLuaExecute</b> (const <a class="el" href="_z_f_core_type_def___char_type_8h.html#aae91c42d33bfa0346478038b37ce2764">zfchar</a> *buf)</td></tr>
<tr class="memdesc:a8b62342afcf8432691f6fd69c51a0b8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">see <a class="el" href="#a3c13beac94e3fba795f03e308d2cbd22" title="main entry for lua module, execute lua code">ZFLuaExecute</a> <br /></td></tr>
<tr class="separator:a8b62342afcf8432691f6fd69c51a0b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c88b48de17dfd8adea427346e1ba1f7" id="r_a9c88b48de17dfd8adea427346e1ba1f7"><td class="memItemLeft" align="right" valign="top"><a id="a9c88b48de17dfd8adea427346e1ba1f7" name="a9c88b48de17dfd8adea427346e1ba1f7"></a>
<a class="el" href="classzfauto.html">zfauto</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ZFLuaExecute</b> (const <a class="el" href="class_z_f_input.html">ZFInput</a> &amp;input, <a class="el" href="class_z_f_object.html">ZFObject</a> *param0, <a class="el" href="class_z_f_object.html">ZFObject</a> *param1=(((<a class="el" href="class_z_f_object.html">ZFObject</a> *const &amp;) _ZFP_ZFMP_DEF)), <a class="el" href="class_z_f_object.html">ZFObject</a> *param2=(((<a class="el" href="class_z_f_object.html">ZFObject</a> *const &amp;) _ZFP_ZFMP_DEF)), <a class="el" href="class_z_f_object.html">ZFObject</a> *param3=(((<a class="el" href="class_z_f_object.html">ZFObject</a> *const &amp;) _ZFP_ZFMP_DEF)), <a class="el" href="class_z_f_object.html">ZFObject</a> *param4=(((<a class="el" href="class_z_f_object.html">ZFObject</a> *const &amp;) _ZFP_ZFMP_DEF)), <a class="el" href="class_z_f_object.html">ZFObject</a> *param5=(((<a class="el" href="class_z_f_object.html">ZFObject</a> *const &amp;) _ZFP_ZFMP_DEF)), <a class="el" href="class_z_f_object.html">ZFObject</a> *param6=(((<a class="el" href="class_z_f_object.html">ZFObject</a> *const &amp;) _ZFP_ZFMP_DEF)))</td></tr>
<tr class="memdesc:a9c88b48de17dfd8adea427346e1ba1f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">see <a class="el" href="#a3c13beac94e3fba795f03e308d2cbd22" title="main entry for lua module, execute lua code">ZFLuaExecute</a> <br /></td></tr>
<tr class="separator:a9c88b48de17dfd8adea427346e1ba1f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cf949b7b67308470d5e0773aa391ba3" id="r_a0cf949b7b67308470d5e0773aa391ba3"><td class="memItemLeft" align="right" valign="top"><a id="a0cf949b7b67308470d5e0773aa391ba3" name="a0cf949b7b67308470d5e0773aa391ba3"></a>
<a class="el" href="classzfauto.html">zfauto</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ZFLuaExecute</b> (const <a class="el" href="_z_f_core_type_def___char_type_8h.html#aae91c42d33bfa0346478038b37ce2764">zfchar</a> *buf, <a class="el" href="class_z_f_object.html">ZFObject</a> *param0, <a class="el" href="class_z_f_object.html">ZFObject</a> *param1=(((<a class="el" href="class_z_f_object.html">ZFObject</a> *const &amp;) _ZFP_ZFMP_DEF)), <a class="el" href="class_z_f_object.html">ZFObject</a> *param2=(((<a class="el" href="class_z_f_object.html">ZFObject</a> *const &amp;) _ZFP_ZFMP_DEF)), <a class="el" href="class_z_f_object.html">ZFObject</a> *param3=(((<a class="el" href="class_z_f_object.html">ZFObject</a> *const &amp;) _ZFP_ZFMP_DEF)), <a class="el" href="class_z_f_object.html">ZFObject</a> *param4=(((<a class="el" href="class_z_f_object.html">ZFObject</a> *const &amp;) _ZFP_ZFMP_DEF)), <a class="el" href="class_z_f_object.html">ZFObject</a> *param5=(((<a class="el" href="class_z_f_object.html">ZFObject</a> *const &amp;) _ZFP_ZFMP_DEF)), <a class="el" href="class_z_f_object.html">ZFObject</a> *param6=(((<a class="el" href="class_z_f_object.html">ZFObject</a> *const &amp;) _ZFP_ZFMP_DEF)))</td></tr>
<tr class="memdesc:a0cf949b7b67308470d5e0773aa391ba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">see <a class="el" href="#a3c13beac94e3fba795f03e308d2cbd22" title="main entry for lua module, execute lua code">ZFLuaExecute</a> <br /></td></tr>
<tr class="separator:a0cf949b7b67308470d5e0773aa391ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2cfc1fd6b6f0f48290a15058508f555" id="r_ae2cfc1fd6b6f0f48290a15058508f555"><td class="memItemLeft" align="right" valign="top"><a id="ae2cfc1fd6b6f0f48290a15058508f555" name="ae2cfc1fd6b6f0f48290a15058508f555"></a>
<a class="el" href="classzfauto.html">zfauto</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ZFLuaExecuteDetail</b> (const <a class="el" href="class_z_f_input.html">ZFInput</a> &amp;input, const <a class="el" href="class_z_f_core_array.html">ZFCoreArray</a>&lt; <a class="el" href="classzfauto.html">zfauto</a> &gt; &amp;luaParams, <a class="el" href="_z_f_core_type_def___core_type_8h.html#a18319824a3b98c37ac216ca6f511a323">zfbool</a> *success=(zft_zfnull), <a class="el" href="_z_f_core_type_def___string_type_8h.html#a7fe5c17baced006251bac354c4ded743">zfstring</a> *errorHint=(zft_zfnull), void *L=(zft_zfnull))</td></tr>
<tr class="memdesc:ae2cfc1fd6b6f0f48290a15058508f555"><td class="mdescLeft">&#160;</td><td class="mdescRight">see <a class="el" href="#a3c13beac94e3fba795f03e308d2cbd22" title="main entry for lua module, execute lua code">ZFLuaExecute</a> <br /></td></tr>
<tr class="separator:ae2cfc1fd6b6f0f48290a15058508f555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22862ef3e36cacbc60a0907ed352d9c5" id="r_a22862ef3e36cacbc60a0907ed352d9c5"><td class="memItemLeft" align="right" valign="top"><a id="a22862ef3e36cacbc60a0907ed352d9c5" name="a22862ef3e36cacbc60a0907ed352d9c5"></a>
<a class="el" href="classzfauto.html">zfauto</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ZFLuaExecuteDetail</b> (const <a class="el" href="_z_f_core_type_def___char_type_8h.html#aae91c42d33bfa0346478038b37ce2764">zfchar</a> *buf, const <a class="el" href="class_z_f_core_array.html">ZFCoreArray</a>&lt; <a class="el" href="classzfauto.html">zfauto</a> &gt; &amp;luaParams, <a class="el" href="_z_f_core_type_def___core_type_8h.html#a18319824a3b98c37ac216ca6f511a323">zfbool</a> *success=(zft_zfnull), <a class="el" href="_z_f_core_type_def___string_type_8h.html#a7fe5c17baced006251bac354c4ded743">zfstring</a> *errorHint=(zft_zfnull), void *L=(zft_zfnull))</td></tr>
<tr class="memdesc:a22862ef3e36cacbc60a0907ed352d9c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">see <a class="el" href="#a3c13beac94e3fba795f03e308d2cbd22" title="main entry for lua module, execute lua code">ZFLuaExecute</a> <br /></td></tr>
<tr class="separator:a22862ef3e36cacbc60a0907ed352d9c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>execute lua script </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a3c13beac94e3fba795f03e308d2cbd22" name="a3c13beac94e3fba795f03e308d2cbd22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c13beac94e3fba795f03e308d2cbd22">&#9670;&#160;</a></span>ZFLuaExecute()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classzfauto.html">zfauto</a> ZFLuaExecute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_z_f_input.html">ZFInput</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>input</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>main entry for lua module, execute lua code </p>
<p>thanks to powerful reflection mechanism in ZFFramework, most of components are registered to lua by reflection automatically<br  />
<br  />
all types of ZFFramework are wrapped as <a class="el" href="classzfauto.html" title="a ZFObject holder which would release content object automatically when destroyed">zfauto</a> in lua world, including: <a class="el" href="class_z_f_object.html" title="base class of all objects">ZFObject</a> types (wrapped directly) and non-ZFObject normal C++ types (wrapped by <a class="el" href="class_z_f_type_id_wrapper.html" title="dummy base for all wrapper types, see ZFTypeId::Value">ZFTypeIdWrapper</a>)<br  />
then, all reflectable <a class="el" href="class_z_f_method.html" title="reflectable method for ZFObject">ZFMethod</a> supply <a class="el" href="_z_f_method_generic_invoker_8h.html#a5246f514f27b66ed22dfa91badb8c005" title="generic invoker for advanced reflection, see ZFMethod::methodGenericInvoker">ZFMethodGenericInvoker</a> to invoke the method without knowing all actual types<br  />
<br  />
here is a list of functions available in lua to communicate with ZFFramework:</p><ul>
<li>"zfAlloc("ClassName" [params...])" or "ClassName([params...])"<br  />
 alloc a <a class="el" href="class_z_f_object.html" title="base class of all objects">ZFObject</a> type<br  />
 "ClassName" can be <a class="el" href="classv___z_f_class.html" title="type wrapper for ZFTypeId::Value">v_ZFClass</a>, <a class="el" href="classv__zfstring.html" title="type wrapper for ZFTypeId::Value">v_zfstring</a>, or native lua string<br  />
 if extra init param passed, your class must supplys reflectable <a class="el" href="class_z_f_object.html#a11e162b1f89e7ce8143ad9c1218496ed" title="override this to init your object">ZFObject::objectOnInit</a></li>
<li>invoker<ul>
<li>"ret = zfl_call(obj, "functionName", param0, param1, ...)" or "obj:functionName(param0, param1, ...)"<br  />
 call object's instance method, params are optional<br  />
 for "functionName", see <a class="el" href="_z_f_method_serializable_8h.html#ac6ff736d308cd11a970b1780f3476985" title="see ZFTYPEID_DECLARE">ZFTypeId_ZFMethod</a><br  />
 "functionName" can be <a class="el" href="classv___z_f_method.html" title="type wrapper for ZFTypeId::Value">v_ZFMethod</a>, <a class="el" href="classv__zfstring.html" title="type wrapper for ZFTypeId::Value">v_zfstring</a>, or native lua string, while other types must exactly match the original types</li>
<li>"ret = zfl_call(zfnull, "ClassOrNamespace.methodName", param0, param1, ...)" or "ret = ClassOrNamespace.methodName(param0, param1, ...)"<br  />
 call global function or static class member method, params are optional<br  />
 for "functionName", see <a class="el" href="_z_f_method_serializable_8h.html#ac6ff736d308cd11a970b1780f3476985" title="see ZFTYPEID_DECLARE">ZFTypeId_ZFMethod</a><br  />
 "functionName" can be <a class="el" href="classv___z_f_method.html" title="type wrapper for ZFTypeId::Value">v_ZFMethod</a>, <a class="el" href="classv__zfstring.html" title="type wrapper for ZFTypeId::Value">v_zfstring</a>, <a class="el" href="classv___z_f_class.html" title="type wrapper for ZFTypeId::Value">v_ZFClass</a>, or native lua string, while other types must exactly match the original types<br  />
 these namespace are considered as the same:<ul>
<li><a class="el" href="_z_f_namespace_8h.html#a66584992a45633584a15a6ecad2f66f4" title="global namespace id for impl">ZF_NAMESPACE_GLOBAL_NAME</a></li>
<li><a class="el" href="_z_f_namespace_8h.html#a83e4677aafb6522c655a0db39790b40f" title="global namespace id for impl">ZF_NAMESPACE_GLOBAL_ABBR_NAME</a></li>
<li>empty string</li>
</ul>
</li>
<li>while calling functions with lua raw string, such as "func('abc')", we will try to convert to proper param type by string converter, if overload functions exists, conversion may take more than once, until it matches first function</li>
</ul>
</li>
<li><a class="el" href="class_z_f_enum.html" title="abstract base class of all enum type of ZFFramework">ZFEnum</a><ul>
<li>"YourEnum.e_YourEnumValue()"<br  />
 access the enum value</li>
<li>"YourEnumFlags('YourEnumValue1|YourEnumValue2')" or "YourEnumFlags(YourEnum.e_YourEnumValue1(), YourEnum.e_YourEnumValue2, ...)"<br  />
 create enum flags</li>
</ul>
</li>
<li>value holder<ul>
<li>"value = YourTypeName("yourTypeData")" or "value = zfAlloc("YourTypeName")" or "value = YourTypeName()"<br  />
 create a non-ZFObject type registered by <a class="el" href="_z_f_type_id_declare_8h.html#a245c14fb891739fe4d52a515c58f35cb" title="register a type for reflection">ZFTYPEID_DECLARE</a>, return the associated "YourTypeName" that holds the value<br  />
 "YourTypeName" represents the type name in <a class="el" href="_z_f_type_id_declare_8h.html#a245c14fb891739fe4d52a515c58f35cb" title="register a type for reflection">ZFTYPEID_DECLARE</a><br  />
 "yourTypeData" store string datas that would be decoded by YourTypeNameFromString<br  />
 "yourTypeData" can be <a class="el" href="classv__zfstring.html" title="type wrapper for ZFTypeId::Value">v_zfstring</a>, or native lua string<br  />
 if your value holder supplys reflectable <a class="el" href="class_z_f_object.html#a11e162b1f89e7ce8143ad9c1218496ed" title="override this to init your object">ZFObject::objectOnInit</a> (<a class="el" href="_z_f_object_declare_8h.html#a4b6e269af239990d051fb0f1bb49d57c" title="see ZFOBJECT_ON_INIT_INLINE_1">ZFOBJECT_ON_INIT_DECLARE_1</a> series), the value holder can also be constructed by function like call: "YourTypeName(param0, param1)"</li>
<li>"value:yourFunc()" or "YourTypeName.YourFunc()"<br  />
 for non-ZFObject types that wrapped by <a class="el" href="_z_f_type_id_declare_8h.html#a245c14fb891739fe4d52a515c58f35cb" title="register a type for reflection">ZFTYPEID_DECLARE</a>, you may use <a class="el" href="_z_f_method_user_register_8h.html#a5200ba93cd7d20b2afedf71337b0f6c9" title="see ZFMethodUserRegister_0">ZFMETHOD_USER_REGISTER_0</a> series to register methods to its wrapper type "YourTypeName", then the methods can be invoked directly to your value type</li>
</ul>
</li>
<li>value converter<ul>
<li>"zfl_value(v)"<br  />
 convert a value to lua's raw value, the result lua value can be:<ul>
<li>lua string</li>
<li>lua integer</li>
<li>lua number</li>
<li>lua boolean</li>
</ul>
</li>
<li>these types are automatically converted when return from cpp to lua:<ul>
<li><a class="el" href="classv__zfbool.html" title="type wrapper for ZFTypeId::Value">v_zfbool</a> =&gt; lua boolean : use <a class="el" href="classv__zfbool_holder.html" title="a dummy class that wraps v_zfbool">v_zfboolHolder</a> explicitly if necessary</li>
</ul>
</li>
</ul>
</li>
<li>value comparer<ul>
<li>"zfl_cmp(v0, v1)"<br  />
 compare two values, including <a class="el" href="class_z_f_object.html" title="base class of all objects">ZFObject</a> types and lua types, return:<ul>
<li>-2 : error or uncomparable</li>
<li>-1 : v0 &lt; v1</li>
<li>0 : v0 == v1</li>
<li>1 : v0 &gt; v1</li>
</ul>
</li>
<li>"zfl_eq(v0, v1)"<br  />
 similar to zfl_cmp, compare two values<br  />
 note: due to limitation of lua, <code>v0 == v1</code> won't work as expected when not all of them are both primitive type or both <a class="el" href="class_z_f_object.html" title="base class of all objects">ZFObject</a> type, it's recommended to use zfl_eq for most case</li>
</ul>
</li>
<li>callback<ul>
<li><p class="startli">"ZFCallbackForLua(luaFunc)"<br  />
 create a <a class="el" href="class_z_f_listener.html" title="listener as ZFCallback, mostly used by ZFObject::observerNotify">ZFListener</a> from lua function<br  />
 the lua function's proto type must be: </p><div class="fragment"><div class="line">function myLuaCallback(zfargs)</div>
<div class="line">end</div>
</div><!-- fragment --><p> <br  />
 about thread safe:</p><ul>
<li>when the callback called in the same <a class="el" href="class_z_f_thread.html" title="thread utility">ZFThread</a> where the callback created, the callback should work as expected, all variable capture should work</li>
<li>when the callback called in different <a class="el" href="class_z_f_thread.html" title="thread utility">ZFThread</a>:<ul>
<li>the callback and all captured upvalues would be copied to a new lua state managed by the <a class="el" href="class_z_f_thread.html" title="thread utility">ZFThread</a></li>
<li>only these value types can be captured:<ul>
<li>lua primitive types: boolean, integer, number, string</li>
<li><a class="el" href="class_z_f_object.html" title="base class of all objects">ZFObject</a> types</li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="startli"><br  />
 further more, lua function can be converted to <a class="el" href="class_z_f_listener.html" title="listener as ZFCallback, mostly used by ZFObject::observerNotify">ZFListener</a> implicitly </p><div class="fragment"><div class="line">button:observerAdd(<a class="code hl_class" href="class_z_f_u_i_button.html">ZFUIButton</a>.<a class="code hl_function" href="class_z_f_u_i_button.html#a652e3bb7b49a80ba75bb0aca73b51e8d">E_ButtonOnClick</a>(), function(zfargs)</div>
<div class="line">    end)</div>
<div class="ttc" id="aclass_z_f_u_i_button_html"><div class="ttname"><a href="class_z_f_u_i_button.html">ZFUIButton</a></div><div class="ttdoc">abstract button</div><div class="ttdef"><b>Definition</b> ZFUIButton.h:42</div></div>
<div class="ttc" id="aclass_z_f_u_i_button_html_a652e3bb7b49a80ba75bb0aca73b51e8d"><div class="ttname"><a href="class_z_f_u_i_button.html#a652e3bb7b49a80ba75bb0aca73b51e8d">ZFUIButton::E_ButtonOnClick</a></div><div class="ttdeci">static zfidentity E_ButtonOnClick(void)</div><div class="ttdoc">see ZFObject::observerNotify</div></div>
</div><!-- fragment --><p> useful in dynamic method register: </p><div class="fragment"><div class="line"><a class="code hl_class" href="class_z_f_dynamic.html">ZFDynamic</a>()</div>
<div class="line">    :staticMethod(<span class="stringliteral">&#39;MyRetType&#39;</span>, <span class="stringliteral">&#39;myMethod&#39;</span>, <a class="code hl_class" href="class_z_f_m_p.html">ZFMP</a>()</div>
<div class="line">        :mp(<span class="stringliteral">&#39;MyParamType&#39;</span>, <span class="stringliteral">&#39;p0&#39;</span>)</div>
<div class="line">    , function(zfargs)</div>
<div class="line">        ---@type MyRetType</div>
<div class="line">        local p0 = zfargs:param0()</div>
<div class="line"> </div>
<div class="line">        -- return by either of ways:</div>
<div class="line">        zfargs:result(MyRetType())</div>
<div class="line">        -- or simply return</div>
<div class="line">        -- return MyRetType()</div>
<div class="line">    end)</div>
<div class="ttc" id="aclass_z_f_dynamic_html"><div class="ttname"><a href="class_z_f_dynamic.html">ZFDynamic</a></div><div class="ttdoc">util class to dynamic register class/method/property</div><div class="ttdef"><b>Definition</b> ZFDynamicRegisterUtil.h:56</div></div>
<div class="ttc" id="aclass_z_f_m_p_html"><div class="ttname"><a href="class_z_f_m_p.html">ZFMP</a></div><div class="ttdoc">util for ZFDynamic::method</div><div class="ttdef"><b>Definition</b> ZFMethodDynamicRegister.h:197</div></div>
</div><!-- fragment --></li>
<li>"output:output(text[, size, result])"<br  />
 write to output callback</li>
<li>"input:input(buf [, size, result])"<br  />
 read from input callback</li>
</ul>
</li>
<li>array<ul>
<li>"ZFCoreArrayCreate([a, b, c, ...])"<br  />
 create a array, params support these types:<ul>
<li>zfauto</li>
<li>native lua number (stored as <a class="el" href="classv__zfdouble.html" title="type wrapper for ZFTypeId::Value">v_zfdouble</a>)</li>
<li>native lua string (stored as <a class="el" href="classv__zfstring.html" title="type wrapper for ZFTypeId::Value">v_zfstring</a>)</li>
</ul>
</li>
</ul>
</li>
<li>param and return value<ul>
<li>simply use lua standard logic to process params and return values, here's some example: <div class="fragment"><div class="line">-- get all params</div>
<div class="line">local args = {...};</div>
<div class="line">local argsCount = #args;</div>
<div class="line">-- <span class="keywordflow">return</span> value</div>
<div class="line"><span class="keywordflow">return</span> args[1];</div>
</div><!-- fragment --> note that, all params passed from <a class="el" href="#a3c13beac94e3fba795f03e308d2cbd22" title="main entry for lua module, execute lua code">ZFLuaExecute</a> are all <a class="el" href="classzfauto.html" title="a ZFObject holder which would release content object automatically when destroyed">zfauto</a> type</li>
</ul>
</li>
<li>util<ul>
<li>"zfl_iter(a)"<br  />
 util to loop <a class="el" href="class_z_f_core_array.html" title="light weight array">ZFCoreArray</a>, <a class="el" href="class_z_f_container.html" title="container of ZFObject">ZFContainer</a>, <a class="el" href="class_z_f_key_value_container.html" title="key value container of ZFObject">ZFKeyValueContainer</a>: <div class="fragment"><div class="line">-- <span class="keywordflow">for</span> array type</div>
<div class="line"><span class="keywordflow">for</span> i,e in zfl_iter(a) <span class="keywordflow">do</span></div>
<div class="line">end</div>
<div class="line">-- <span class="keywordflow">for</span> map type</div>
<div class="line"><span class="keywordflow">for</span> i,k,v in zfl_iter(m) <span class="keywordflow">do</span></div>
<div class="line">end</div>
</div><!-- fragment --></li>
<li>"zfl_range(n, ...)"<br  />
 util to perform range loop: <div class="fragment"><div class="line"><span class="keywordflow">for</span> i in zfl_range(xxx) <span class="keywordflow">do</span></div>
<div class="line">end</div>
</div><!-- fragment --><ul>
<li>"zfl_range(n)" : loop in range <code>[0, n)</code></li>
<li>"zfl_range(n0, n1)" : loop in range <code>[n0, n1)</code></li>
<li>"zfl_range(n0, n1, offset)" : loop in range <code>[n0, n1)</code>, each step with specified offset</li>
</ul>
</li>
</ul>
</li>
<li>local path info spec<ul>
<li>"zfl_L()"<br  />
 lua_State of current chunk, stored as <a class="el" href="classv__zfptr.html" title="type wrapper for ZFTypeId::Value">v_zfptr</a></li>
<li>"ZFLocalPathInfo([localPath])"<br  />
 return path info of current context, null if not available</li>
<li>"zfimport(localFilePath)"<br  />
 util method for <a class="el" href="#a3c13beac94e3fba795f03e308d2cbd22" title="main entry for lua module, execute lua code">ZFLuaExecute</a> + <a class="el" href="_z_f_i_o_def__path_info_8h.html#aec11a8cca3232a74bf2246b86e666040" title="util to create a file input callback">ZFInputForLocal</a>, useful to load local resource or class definition</li>
</ul>
</li>
<li>debug helper<ul>
<li>"zfl_tableInfo(v)" or "zfl_tableInfoPrint(v)"<br  />
 return string that represents the table</li>
<li>"zfl_trace()"<br  />
 return lua stack trace as string</li>
</ul>
</li>
</ul>
<p>note:</p><ul>
<li>all types would be registered automatically,</li>
<li>for dynamically loaded library, all types would also be registered normally, however, won't be automatically unregistered when unloaded </li>
</ul>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_c80360d3694a8cbfb6668b9233fa1819.html">ZF</a></li><li class="navelem"><a class="el" href="dir_5e162f224ae5f14170760138c0f5090c.html">ZFLua</a></li><li class="navelem"><a class="el" href="dir_e461568de8075956895feb76b4aa4344.html">zfsrc</a></li><li class="navelem"><a class="el" href="dir_5688c3f8dd578456e7822b9e257f4020.html">ZFLua</a></li><li class="navelem"><a class="el" href="_z_f_lua_execute_8h.html">ZFLuaExecute.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
